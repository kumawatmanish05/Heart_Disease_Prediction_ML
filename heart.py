# -*- coding: utf-8 -*-
"""Heart.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oR2fURJBesjtZWG-th9181VYLjd0u4Nu
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv('/content/heart.csv')

df

"""# **EDA**"""

df.columns

df.shape

df.info()

df.describe()

df.duplicated().sum()

df['HeartDisease'].value_counts().plot(kind="bar")

df.isnull().sum()

"""#**The data is cleaned till now but is wronged**"""

def plotting(var,num):
    plt.subplot(2,2,num)
    sns.histplot(df[var],kde=True)
    plt.title(var)

plotting('Age',1)
plotting('MaxHR',4)
plotting('Cholesterol',3)
plotting('RestingBP',2)

plt.tight_layout()

df['Cholesterol'].value_counts() #Here 172 person has 0 cholestrol that's not possible

ch_mean = df.loc[df['Cholesterol'] != 0,'Cholesterol'].mean()
df['Cholesterol'] = df['Cholesterol'].replace(0,ch_mean)
df['Cholesterol'] = df['Cholesterol'].round(2)

df['Cholesterol'].value_counts()

resting_bp_mean = df.loc[df['RestingBP'] != 0, 'RestingBP'].mean()
df['RestingBP'] = df['RestingBP'].replace(0,ch_mean)
df['RestingBP'] = df['RestingBP'].round(2)

df['RestingBP'].value_counts()

def plotting(var,num):
    plt.subplot(2,2,num)
    sns.histplot(df[var],kde=True)
    plt.title(var)

plotting('Age',1)
plotting('MaxHR',4)
plotting('Cholesterol',3)
plotting('RestingBP',2)

plt.tight_layout()

pip install sheryanalysis==0.1.0

import sheryanalysis as sh
sh.analyze(df)

sns.countplot(x= df['Sex'],hue = df['HeartDisease'])

sns.countplot(x= df['ChestPainType'],hue = df['HeartDisease'])

sns.countplot(x= df['FastingBS'],hue = df['HeartDisease'])

sns.boxplot(y = 'Cholesterol', x = 'HeartDisease', data = df)

#A Violin Plot is a data visualization that combines a box plot and a KDE (Kernel Density Estimate) plot.
# It shows the distribution, probability density, and summary statistics of the data — all in one plot.

sns.violinplot(x = 'HeartDisease', y = 'Age', data = df)

"""A **Heatmap** is a 2D colored representation of data where values are shown using color intensity. It's most commonly used for:

<> Correlation matrices
<> Confusion matrices
<> Any data in a matrix format (rows × columns)


"""

sns.heatmap(df.corr(numeric_only=True), annot = True)

#Data Preprocessing

df_encode = pd.get_dummies(df,drop_first=True)
df_encode

df_encode.columns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, f1_score, classification_report
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier

X = df_encode.drop('HeartDisease',axis = 1)
y = df_encode['HeartDisease']

X_train, X_test, y_train, y_test = train_test_split(
    X, y, stratify=y, test_size=0.2, random_state=42)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

models = {
    "Logistic Regression": LogisticRegression(),
    "KNN": KNeighborsClassifier(),
    "Naive Bayes": GaussianNB(),
    "Decision Tree": DecisionTreeClassifier(),
    "SVM (RBF Kernel)": SVC(probability=True)
}

results = []

for name, model in models.items():
    model.fit(X_train_scaled, y_train)
    y_pred = model.predict(X_test_scaled)
    acc = accuracy_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred)
    results.append({
        'Model': name,
        'Accuracy': round(acc, 4),
        'F1 Score': round(f1, 4)
    })

results

import joblib
joblib.dump(models['KNN'],'KNN_heart.pkl')
joblib.dump(scaler,'scaler.pkl')
joblib.dump(X.columns.tolist(),'columns.pkl')